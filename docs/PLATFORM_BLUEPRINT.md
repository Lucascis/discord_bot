# ðŸ“˜ Blueprint de Plataforma: Arquitectura, Estructura y Roadmap

Este documento redefine la visiÃ³n, arquitectura y estructura del proyecto para evolucionar de un bot de mÃºsica de Discord a una plataforma modular y multiplataforma con enfoque en escalabilidad, mantenibilidad por IA y comercializaciÃ³n por suscripciones.

Estado: Propuesta inicial aprobable para ejecuciÃ³n por fases.

---

## 1) VisiÃ³n y Principios

### VisiÃ³n
Construir una plataforma modular de integraciones en tiempo real, donde Discord es la primera integraciÃ³n (bot de mÃºsica con Lavalink), pero el core permite agregar rÃ¡pidamente nuevas superficies (Web, Slack, Telegram, etc.), ofrecer planes por suscripciÃ³n, personalizaciones y mÃ©tricas avanzadas.

### Principios
- Modularidad estricta y contratos tipados entre mÃ³dulos (TypeScript en todo el stack).
- Arquitectura orientada a eventos con lÃ­mites claros (Domain/Core separado de Adapters).
- Observabilidad profunda desde el dÃ­a 1 (tracing, logs, mÃ©tricas y auditorÃ­a).
- Escalabilidad horizontal pragmÃ¡tica (Redis/Streams/Kafka evolutivo; Postgres con Prisma).
- DiseÃ±ado para ser mantenido por IA (nombres claros, ADRs, convenciones, documentaciÃ³n viva).
- Seguridad por defecto (secrets, RBAC, idempotencia, auditorÃ­a, DLP de tokens).

---

## 2) Gap Analysis del estado actual (docs)

Basado en la documentaciÃ³n vigente:

- Foco actual: bot de mÃºsica para Discord en microservicios (Gateway/Audio/API/Worker) con Redis pub/sub, Postgres+Prisma, Lavalink v4.
- Faltantes para la nueva visiÃ³n:
  - Ausencia de un Core de dominio desacoplado del canal Discord.
  - No existe un SDK de Integraciones para otras plataformas (Slack/Telegram/WebSockets App).
  - Falta un servicio de Billing/Entitlements (planes, lÃ­mites, upgrades/downgrades, Stripe webhook).
  - Portal Web para usuarios y panel de administraciÃ³n (gestiÃ³n de guilds, planes, personalizaciones).
  - DiseÃ±o de multitenencia y modelo de datos para features/flags/entitlements por tenant/guild.
  - EstÃ¡ndares de eventos y contratos compartidos (versionados, esquemas, compatibilidad).
  - Observabilidad de negocio (mÃ©tricas de uso, conversiÃ³n, retenciÃ³n, LTV) y de producto.
  - Runbooks/SLOs/operabilidad a nivel plataforma y no sÃ³lo por servicio.

ConclusiÃ³n: la base tÃ©cnica es sÃ³lida para Discord, pero falta la capa de plataforma (core + billing + web + integraciÃ³n multiplataforma + gobernanza de contratos).

---

## 3) Arquitectura Propuesta (alto nivel)

PatrÃ³n: Hexagonal/Ports & Adapters + Event-Driven. Monorepo TypeScript con pnpm + Turborepo.

Servicios (apps):
- gateway-discord: Adaptador Discord (discord.js v14), slash commands, mapping a comandos de dominio.
- audio: IntegraciÃ³n con Lavalink, colas y efectos; escala horizontal con mÃºltiples nodos Lavalink.
- platform-api: API para Web/Integraciones (REST/HTTP + Webhooks; opcional GraphQL o tRPC mÃ¡s adelante).
- worker: Jobs (BullMQ), programaciones, envÃ­o de emails/notifs.
- billing: IntegraciÃ³n con Stripe (checkout, portal, webhooks), cÃ¡lculo de entitlements.
- web: Portal de usuario (Next.js), login con Discord, gestiÃ³n de guilds, subscripciones y paneles.
- admin: Consola interna (Next.js) con admin y soporte.

Paquetes (packages):
- core: dominio, casos de uso, entidades, polÃ­ticas y validaciones; independiente de Discord/Web.
- integration-sdk: contratos/ports para implementar nuevos adaptadores (Discord/Slack/Telegram/WebSocket-client).
- events: definiciÃ³n de eventos, esquemas y versionado (zod), publicadores/suscriptores genÃ©ricos.
- database: Prisma Client, migraciones, repositorios; modelos multi-tenant.
- config: carga/validaciÃ³n de env con zod; perfiles dev/prod.
- logger: pino + formato; bindings de request.
- feature-flags: flags y gates; OpenFeature-ready; cachÃ© de entitlements.
- commands-discord: catÃ¡logo y tipado de slash commands; parseo y ayudas.
- billing-shared: contratos de planes, lÃ­mites, entitlements y helpers de pricing.

Infra base:
- Postgres (Aurora/Neon/Cockroach opcional) para transaccional; Prisma.
- Redis (Cluster) para cachÃ©, rate limits, sesiones y pub/sub inicial.
- Event Bus: Redis Streams en Fase 1; evolucionable a NATS/Kafka en Fase 3.
- Observabilidad: OpenTelemetry â†’ OTEL Collector â†’ Prometheus + Tempo + Loki + Grafana.

Seguridad:
- Secret management (SOPS/1Password/Vault), rotaciÃ³n de tokens, scoping de permisos.
- Idempotencia en webhooks y comandos crÃ­ticos; auditorÃ­a en `AuditLog`.

---

## 4) Modelo de Datos (resumen)

Entidades principales (Prisma):
- Account(User), Identity(Discord), Organization/Tenant (opcional), Guild, Member
- Plan, Subscription, Entitlement, FeatureFlag
- PlayerSession, Queue, QueueItem, PlaybackMetrics
- PanelConfig (personalizaciones UI), WebhookEndpoint
- AuditLog, ApiKey, RateLimit, QuotaUsage

Claves:
- Multi-tenant por `guildId` (Discord) y/o `tenantId`.
- `Entitlement` materializado y cacheado en Redis para gating de features.
- MÃ©tricas de reproducciÃ³n en tabla optimizada + export a TSDB (ClickHouse/Timescale si escala).

---

## 5) Sistema de Planes (Premium)

Tiers propuestos (ejemplo):
- Free: 3 instancia por guild, bitrate estÃ¡ndar, cola limitada, sin filtros avanzados. Sin UI, sÃ³lo comandos y mensajes bÃ¡sicos de nowplaying.
- Pro: 4â€“5 instancias, mejor calidad (segÃºn lÃ­mites de Discord), filtros y autoplay avanzado. UI con botones
- Elite: 5+ instancias, crossfade, filtros premium, prioridad de cola, paneles avanzados.

Gating por entitlement:
- Calidad/bitrate (respetando lÃ­mites efectivos de Discord por boost del servidor).
- Concurrencia de players por guild y lÃ­mite de cola.
- Filtros (eq, timescale, nightcore, karaoke), crossfade, normalizaciÃ³n, autoplay ML.
- PersonalizaciÃ³n de paneles (themes, layouts, embeds persistentes).

Billing:
- Stripe Checkout + Customer Portal.
- Webhooks idempotentes (`billing` service) â†’ `Entitlement.update`.
- Prorrateos, upgrades/downgrades, trials y cupones.

---

## 6) Flujos Clave

Slash command â†’ dominio â†’ audio:
1) Usuario ejecuta `/play <query>` en Discord.
2) gateway-discord mapea a `Core.playRequest` (comando dominio) y agrega metadata de contexto (guild, user).
3) core valida entitlements/quotas; publica `music.play.requested`.
4) audio consume evento, resuelve fuente (LavaSrc), encola en Lavalink y emite `music.play.started`.
5) gateway actualiza UI (mensajes/embeds) y mÃ©tricas.

Stripe webhook â†’ entitlement:
1) `billing` recibe `checkout.session.completed`/`invoice.paid`.
2) Verifica firma, idempotencia y customer â†” guild mapping.
3) Actualiza `Subscription` + `Entitlement`; invalida cachÃ© Redis.

Web portal â†’ gestiÃ³n de guild:
1) Usuario inicia sesiÃ³n con Discord (OAuth).
2) Visualiza guilds administrables, estado del plan y personalizaciones.
3) Cambios se aplican vÃ­a `platform-api` y se reflejan en gateway.

---

## 7) Nueva Estructura de Repositorio (monorepo)

```text
.
â”œâ”€ apps/
â”‚  â”œâ”€ gateway-discord/
â”‚  â”œâ”€ audio/
â”‚  â”œâ”€ platform-api/
â”‚  â”œâ”€ worker/
â”‚  â”œâ”€ billing/
â”‚  â”œâ”€ web/            # Next.js (usuario)
â”‚  â””â”€ admin/          # Next.js (interno)
â”œâ”€ packages/
â”‚  â”œâ”€ core/
â”‚  â”œâ”€ integration-sdk/
â”‚  â”œâ”€ events/
â”‚  â”œâ”€ database/
â”‚  â”œâ”€ config/
â”‚  â”œâ”€ logger/
â”‚  â”œâ”€ feature-flags/
â”‚  â”œâ”€ commands-discord/
â”‚  â””â”€ billing-shared/
â”œâ”€ infra/
â”‚  â”œâ”€ docker/
â”‚  â”œâ”€ k8s/
â”‚  â””â”€ terraform/      # opcional
â””â”€ docs/
   â”œâ”€ INDEX.md
   â”œâ”€ ARCHITECTURE.md
   â”œâ”€ ADR/
   â””â”€ PLATFORM_BLUEPRINT.md  # este documento
```

Convenciones:
- pnpm workspaces + Turborepo para orquestar builds/test/lint por paquete.
- Path aliases controlados por tsconfig base.
- Changesets para versionado de packages y CHANGELOG automÃ¡tico.

---

## 8) DocumentaciÃ³n: Estructura propuesta

- INDEX.md: mapa de navegaciÃ³n por perfiles (dev, ops, producto).
- PLATFORM_BLUEPRINT.md: visiÃ³n, arquitectura y roadmap (este doc).
- ARCHITECTURE.md: diagrama de componentes + contratos/eventos.
- ADR/: decisiones de arquitectura (1 por decisiÃ³n relevante).
- BILLING.md: planes, entitlements, flujos y webhooks.
- INTEGRATIONS/: guÃ­as de adapters (Discord, Web, Slack...).
- DATA_MODEL.md: entidades Prisma y ERD.
- RUNBOOKS/: procedimientos operativos y SLOs.
- SECURITY.md: secretos, RBAC, polÃ­ticas y checklist.
- OBSERVABILITY.md: trazas, mÃ©tricas, logs, dashboards y alertas.

Nota: Mantener docs con owners y fecha de Ãºltima revisiÃ³n al inicio.

---

## 9) Roadmap por Fases (6â€“10 semanas)

Fase 0 â€“ Fundaciones (1 semana)
- Monorepo pnpm + Turborepo, lint/prettier/tsconfig base, CI mÃ­nima.
- Paquetes base: config, logger, events, database (schema bootstrap).
- ADR-000 sobre visiÃ³n/arquitectura/eventos.

Fase 1 â€“ Discord + Audio (2â€“3 semanas)
- gateway-discord con catÃ¡logo de slash commands y mapping a core.
- audio con Lavalink + LavaSrc; colas y efectos bÃ¡sicos; mÃ©tricas.
- core: casos de uso de reproducciÃ³n, colas y validaciÃ³n de entitlements.
- Observabilidad bÃ¡sica (OTEL traces + logs estructurados).

Fase 2 â€“ Billing + Entitlements (1â€“2 semanas)
- Servicio billing con Stripe (checkout, portal) y webhooks idempotentes.
- Modelo `Subscription`/`Entitlement`; cachÃ© Redis; gates en core.
- Rate limits/quotas por guild.

Fase 3 â€“ Web Portal (2 semanas)
- Next.js (web) con login Discord, gestiÃ³n de guilds, vista de plan.
- Ajustes de paneles (themes, layouts); endpoints en platform-api.

Fase 4 â€“ Operabilidad y Escala (1â€“2 semanas)
- Runbooks, dashboards, alertas, SLOs.
- Hardening de seguridad y costos; autoscaling y nodos Lavalink mÃºltiples.

---

## 10) Decisiones TÃ©cnicas Recomendadas

- API: REST JSON primero (OpenAPI) para simplicidad; considerar tRPC/GraphQL luego.
- Event Bus: Redis Streams con contratos en `packages/events` (zod) y versionado.
- DB: Postgres 15 + Prisma; mÃ©tricas de alto volumen a ClickHouse/Timescale si es necesario.
- CachÃ©: Redis Cluster con TTL por `Entitlement`/`Feature` y locks para idempotencia.
- Tests: unitarios (vitest), integraciÃ³n por servicio (docker compose), contract tests (pact) para adapters.
- Seguridad: Helmet/CSRF en web, firma HMAC en webhooks, rotaciÃ³n de secrets.

---

## 11) PrÃ³ximos Pasos Accionables

1) Aprobar esta arquitectura y estructura de monorepo.
2) Crear packages base (`config`, `logger`, `events`, `database`) y bootstrap de `core`.
3) Scaffolding de `gateway-discord` y `audio` con pipeline mÃ­nimo y OTEL.
4) Definir esquema inicial Prisma (Guild, Queue, QueueItem, User, AuditLog, Plan/Subscription/Entitlement).
5) Preparar `infra/docker-compose.dev.yml` con Postgres, Redis y Lavalink.
6) ADR-001: Contratos de eventos iniciales + versionado.

---

## 12) Riesgos y Mitigaciones

- Complejidad por microservicios tempranos â†’ iniciar con lÃ­mites claros y tooling de monorepo (Turbo) y evolucionar servicios sÃ³lo cuando agreguen valor.
- Costos de infraestructura â†’ foco en ambientes dev/preview baratos y autoscaling por demanda.
- LÃ­mite real de calidad en Discord â†’ comunicar niveles reales segÃºn boosts y usar mejoras percibidas (filtros, normalizaciÃ³n, crossfade) en planes premium.

---

## 13) Glosario

- Entitlement: Derecho efectivo a una capacidad/feature segÃºn plan.
- Adapter: ImplementaciÃ³n de un port para una plataforma especÃ­fica.
- Core: LÃ³gica de dominio independiente de la plataforma.
- ADR: Architecture Decision Record.

