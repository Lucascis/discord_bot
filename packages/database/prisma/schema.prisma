datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x"]
}

model GuildConfig {
  id        String   @id @default(cuid())
  guildId   String   @unique
  prefix    String?
  language  String   @default("en")
  createdAt DateTime @default(now())
}

model Queue {
  id        String   @id @default(cuid())
  guildId   String
  createdAt DateTime @default(now())
  voiceChannelId String?
  textChannelId  String?
  items     QueueItem[]

  @@index([guildId])
  @@index([guildId, createdAt])
  @@index([voiceChannelId])
}

model QueueItem {
  id          String   @id @default(cuid())
  queueId     String
  title       String
  url         String
  requestedBy String
  duration    Int
  createdAt   DateTime @default(now())
  queue       Queue    @relation(fields: [queueId], references: [id])

  @@index([queueId])
  @@index([queueId, createdAt])
  @@index([url])
  @@index([requestedBy])
}

model UserProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
}

model AuditLog {
  id        String   @id @default(cuid())
  guildId   String
  userId    String
  action    String
  createdAt DateTime @default(now())
  
  @@index([guildId])
  @@index([userId])
  @@index([guildId, createdAt])
}

model RateLimit {
  id        String   @id @default(cuid())
  key       String   @unique
  count     Int      @default(0)
  expiresAt DateTime
  
  @@index([expiresAt])
}

model FeatureFlag {
  id        String   @id @default(cuid())
  guildId   String
  name      String
  enabled   Boolean  @default(false)
  @@unique([guildId, name])
  @@index([guildId])
  @@index([name])
}

// Premium Features and Configuration
model ServerConfiguration {
  id                    String   @id @default(cuid())
  guildId              String   @unique
  subscriptionTier     String   @default("free") // free, basic, premium, enterprise
  subscriptionExpiresAt DateTime?

  // Plugin feature toggles
  spotifyEnabled       Boolean  @default(false)
  appleMusicEnabled    Boolean  @default(false)
  deezerEnabled        Boolean  @default(false)
  lyricsEnabled        Boolean  @default(false)
  sponsorBlockEnabled  Boolean  @default(true)
  advancedSearchEnabled Boolean @default(false)

  // Audio quality settings
  maxAudioQuality      String   @default("medium") // low, medium, high, lossless
  volumeLimit          Int      @default(200) // 0-200%

  // Queue settings
  maxQueueSize         Int      @default(100)
  maxSongDuration      Int      @default(3600) // seconds
  allowExplicitContent Boolean  @default(true)

  // DJ and permission settings
  djRoleId             String?
  djOnlyMode           Boolean  @default(false)
  voteSkipEnabled      Boolean  @default(true)
  voteSkipThreshold    Float    @default(0.5) // 50%

  // Autoplay settings
  autoplayEnabled      Boolean  @default(false)
  autoplayMode         String   @default("similar") // similar, artist, genre, mixed
  autoplayQueueSize    Int      @default(10) // number of tracks to add when queue is low

  // UI settings
  ephemeralMessages    Boolean  @default(false) // make button interaction messages ephemeral

  // Premium features
  persistentConnection Boolean  @default(false) // 24/7 voice connection (premium only)

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  channels             ChannelConfiguration[]

  @@index([guildId])
  @@index([subscriptionTier])
  @@index([subscriptionExpiresAt])
}

model ChannelConfiguration {
  id                    String   @id @default(cuid())
  guildId              String
  channelId            String

  // Channel-specific overrides
  musicEnabled         Boolean  @default(true)
  playlistsEnabled     Boolean  @default(true)
  spotifyEnabled       Boolean?  // null = inherit from server
  appleMusicEnabled    Boolean?
  deezerEnabled        Boolean?
  lyricsEnabled        Boolean?
  sponsorBlockEnabled  Boolean?

  // Volume and quality overrides
  volumeLimit          Int?     // null = inherit from server
  maxQueueSize         Int?
  maxSongDuration      Int?

  // Channel-specific permissions
  djOnlyMode           Boolean? // null = inherit from server
  allowExplicitContent Boolean?

  serverConfig         ServerConfiguration @relation(fields: [guildId], references: [guildId], onDelete: Cascade)

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([guildId, channelId])
  @@index([guildId])
  @@index([channelId])
}

model UserSubscription {
  id              String   @id @default(cuid())
  userId          String   @unique
  tier            String   @default("free") // free, basic, premium, enterprise
  expiresAt       DateTime?

  // Payment information
  stripeCustomerId     String?
  stripeSubscriptionId String?
  paymentMethod        String? // stripe, paypal, crypto

  // Usage tracking
  monthlyPlayTime      Int     @default(0) // minutes
  monthlyRequests      Int     @default(0)

  // Premium features granted
  premiumServers       Int     @default(0) // number of servers they can upgrade
  customBotEnabled     Boolean @default(false)
  prioritySupport      Boolean @default(false)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([tier])
  @@index([expiresAt])
}

model LyricsCache {
  id         String   @id @default(cuid())
  trackId    String   // unique identifier for track (title + artist hash)
  title      String
  artist     String
  lyrics     String   // full lyrics text
  source     String   // lyrics provider (genius, musixmatch, etc.)
  language   String   @default("en")

  // Timed lyrics support
  timedLyrics Boolean  @default(false)
  lyricsData  String?  // JSON with timed lyrics if available

  createdAt  DateTime @default(now())
  expiresAt  DateTime // lyrics cache expiration

  @@unique([trackId])
  @@index([title, artist])
  @@index([expiresAt])
}

model PlaybackHistory {
  id           String   @id @default(cuid())
  guildId      String
  userId       String
  channelId    String

  // Track information
  title        String
  artist       String
  url          String
  duration     Int
  source       String   // youtube, spotify, deezer, etc.

  // Playback metadata
  playedAt     DateTime @default(now())
  playedFully  Boolean  @default(false) // if track was played to completion
  skipReason   String?  // manual, vote, error, etc.

  // Analytics data
  playbackQuality String? // audio quality used
  pluginsUsed     String[] // which plugins were active

  @@index([guildId])
  @@index([userId])
  @@index([guildId, playedAt])
  @@index([source])
}

// Event Store Tables for Event Sourcing
model EventStoreEvent {
  id                Int      @id @default(autoincrement())
  eventId           String   @unique
  eventType         String
  aggregateId       String
  aggregateType     String
  aggregateVersion  Int
  eventData         String   // JSON
  metadata          String   // JSON
  timestamp         DateTime
  createdAt         DateTime @default(now())
  globalPosition    Int      @default(autoincrement())

  @@index([aggregateId, aggregateType])
  @@index([aggregateId, aggregateType, aggregateVersion])
  @@index([eventType])
  @@index([timestamp])
  @@index([globalPosition])
  @@unique([aggregateId, aggregateType, aggregateVersion])
}

model EventStoreSnapshot {
  id            Int      @id @default(autoincrement())
  aggregateId   String
  aggregateType String
  version       Int
  data          String   // JSON
  timestamp     DateTime
  createdAt     DateTime @default(now())

  @@unique([aggregateId, aggregateType])
  @@index([aggregateType])
  @@index([timestamp])
}

model WebhookSubscription {
  id         String   @id @default(cuid())
  guildId    String
  webhookUrl String
  events     String[] // Array of event types to listen for
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([guildId, webhookUrl])
  @@index([guildId])
  @@index([isActive])
}

// ========================================
// SUBSCRIPTION SYSTEM MODELS
// ========================================

model Subscription {
  id        String   @id @default(cuid())
  guildId   String   @unique

  // Subscription details
  tier      SubscriptionTier @default(FREE)
  status    SubscriptionStatus @default(ACTIVE)

  // Billing cycle
  billingCycle BillingCycle? // null for FREE tier
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?

  // Payment integration
  stripeCustomerId      String?
  stripeSubscriptionId  String?
  stripeProductId       String?
  stripePriceId         String?

  // Trial management
  trialStart   DateTime?
  trialEnd     DateTime?
  isTrialing   Boolean  @default(false)

  // Cancellation
  cancelAtPeriodEnd Boolean  @default(false)
  canceledAt        DateTime?
  cancellationReason String?

  // Metadata
  metadata  String?  // JSON for additional data

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  invoices      Invoice[]
  usageLimits   UsageLimit[]
  usageTracking UsageTracking?

  @@index([guildId])
  @@index([tier])
  @@index([status])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([currentPeriodEnd])
}

model Invoice {
  id             String   @id @default(cuid())
  subscriptionId String
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  // Invoice details
  invoiceNumber  String   @unique
  status         InvoiceStatus @default(PENDING)

  // Amounts (in cents)
  amountDue      Int
  amountPaid     Int      @default(0)
  currency       String   @default("usd")

  // Billing period
  periodStart    DateTime
  periodEnd      DateTime

  // Payment details
  stripeInvoiceId    String?  @unique
  paymentIntentId    String?
  paymentMethod      String?  // stripe, paypal, crypto

  // Dates
  dueDate        DateTime?
  paidAt         DateTime?

  // Metadata
  description    String?
  metadata       String?  // JSON

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([subscriptionId])
  @@index([status])
  @@index([stripeInvoiceId])
  @@index([periodStart, periodEnd])
}

model Feature {
  id          String   @id @default(cuid())

  // Feature identification
  key         String   @unique  // e.g., "concurrent_playbacks", "audio_quality"
  name        String
  description String
  category    FeatureCategory

  // Feature type
  type        FeatureType  // boolean, numeric, string

  // Tier availability
  availableInFree      Boolean @default(false)
  availableInBasic     Boolean @default(false)
  availableInPremium   Boolean @default(false)
  availableInEnterprise Boolean @default(true)

  // Default values per tier (JSON)
  freeValue       String?
  basicValue      String?
  premiumValue    String?
  enterpriseValue String?

  // Metadata
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([key])
  @@index([category])
  @@index([isActive])
}

model UsageLimit {
  id             String   @id @default(cuid())
  subscriptionId String
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  // Limit identification
  limitType      String   // e.g., "concurrent_playbacks", "monthly_tracks", "queue_size"

  // Limit values
  maxValue       Int      // Maximum allowed
  currentValue   Int      @default(0)

  // Reset period
  resetPeriod    ResetPeriod? // null for non-resetting limits
  lastReset      DateTime?
  nextReset      DateTime?

  // Metadata
  metadata       String?  // JSON

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([subscriptionId, limitType])
  @@index([subscriptionId])
  @@index([limitType])
  @@index([nextReset])
}

model UsageTracking {
  id             String   @id @default(cuid())
  subscriptionId String   @unique
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  // Current billing period usage
  tracksPlayed       Int @default(0)
  playbackMinutes    Int @default(0)
  apiRequests        Int @default(0)
  activeGuilds       Int @default(0)

  // All-time usage
  totalTracksPlayed    Int @default(0)
  totalPlaybackMinutes Int @default(0)
  totalApiRequests     Int @default(0)

  // Period tracking
  currentPeriodStart DateTime @default(now())
  currentPeriodEnd   DateTime

  // Last activity
  lastActivity       DateTime @default(now())

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([subscriptionId])
  @@index([currentPeriodEnd])
}

model SubscriptionEvent {
  id             String   @id @default(cuid())
  guildId        String

  // Event details
  eventType      SubscriptionEventType
  tier           SubscriptionTier?
  previousTier   SubscriptionTier?

  // Event data
  description    String?
  metadata       String?  // JSON

  // User who triggered (if applicable)
  userId         String?

  createdAt      DateTime @default(now())

  @@index([guildId])
  @@index([eventType])
  @@index([createdAt])
}

// ========================================
// ENUMS FOR SUBSCRIPTION SYSTEM
// ========================================

enum SubscriptionTier {
  FREE
  BASIC
  PREMIUM
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

enum BillingCycle {
  MONTHLY
  YEARLY
  CUSTOM
}

enum InvoiceStatus {
  PENDING
  PAID
  FAILED
  CANCELED
  REFUNDED
}

enum FeatureCategory {
  PLAYBACK
  AUDIO_QUALITY
  COMMANDS
  SUPPORT
  ANALYTICS
  CUSTOMIZATION
  LIMITS
}

enum FeatureType {
  BOOLEAN
  NUMERIC
  STRING
}

enum ResetPeriod {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum SubscriptionEventType {
  CREATED
  UPGRADED
  DOWNGRADED
  RENEWED
  CANCELED
  EXPIRED
  PAYMENT_FAILED
  PAYMENT_SUCCEEDED
  TRIAL_STARTED
  TRIAL_ENDED
}
