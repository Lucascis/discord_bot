import {
  Client,
  GatewayIntentBits,
  REST,
  Routes,
  SlashCommandBuilder,
  EmbedBuilder,
  PermissionsBitField,
} from 'discord.js';
import { env } from '@discord-bot/config';
import { logger, initializeSentry } from '@discord-bot/logger';
import { createClient } from 'redis';
import { prisma } from '@discord-bot/database';
import { getAutomixEnabled, setAutomixEnabled } from './flags.js';
import { buildControls, resolveTextChannel, type UiState } from './ui.js';
import {
  validateSearchQuery,
  validateInteger,
  validateLoopMode,
  validateSnowflake
} from './validation.js';
import {
  handleInteractionError,
  withErrorHandling,
  withTimeout,
  safeDiscordOperation
} from './errors.js';
import http from 'node:http';
import { Counter, Registry, collectDefaultMetrics } from 'prom-client';
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import crypto from 'node:crypto';
import type { TextChannel } from 'discord.js';
import {
  PlayCommand,
  SimplePublishCommand,
  QueueCommand,
  ShuffleCommand,
  RemoveCommand,
  ClearCommand,
  MoveCommand,
  VolumeCommand,
  LoopCommand,
  SeekCommand,
  NowPlayingCommand,
  type MusicRuntime,
} from './commands.js';
import { SecureRateLimiter } from './security.js';
import { TTLMap } from './cache.js';

// Avoid privileged GuildMembers intent to prevent DisallowedIntents login failures
const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildVoiceStates] });

function hasDjOrAdmin(
  interaction: import('discord.js').ButtonInteraction | import('discord.js').ChatInputCommandInteraction,
): boolean {
  type ApiMember = { roles?: string[]; permissions?: { has?: (p: bigint) => boolean } };
  const gm = interaction.member as import('discord.js').GuildMember | ApiMember | null;
  const djRole = interaction.guild?.roles.cache.find((r) => r.name.toLowerCase() === env.DJ_ROLE_NAME.toLowerCase());
  const isAdmin = !!(gm && 'permissions' in gm && (gm as ApiMember).permissions?.has?.(PermissionsBitField.Flags.Administrator));
  if (!djRole) return isAdmin; // if no role configured/found, admin is enough
  // If roles is an array (Interaction member payload), check by role id
  if (gm && 'roles' in gm && Array.isArray((gm as ApiMember).roles)) {
    return isAdmin || ((gm as ApiMember).roles as string[]).includes(djRole.id);
  }
  // If it's a GuildMember, check the RoleManager cache
  const asGuildMember = gm as import('discord.js').GuildMember | null;
  return isAdmin || !!asGuildMember?.roles.cache.has(djRole.id);
}

client.once('ready', () => {
  logger.info(`Logged in as ${client.user?.tag}`);
});
// Build slash commands from unified command classes (stub runtime only for schema)
const stubRuntime: MusicRuntime = {
  publish: async () => {},
  subscribeOnce: async () => null,
  hasDjOrAdmin: () => true,
  allow: async () => true,
  validators: { validateSearchQuery, validateInteger, validateLoopMode },
};
const registrationCommands = [
  new PlayCommand(stubRuntime),
  new SimplePublishCommand(stubRuntime, { name: 'skip', description: 'Skipped', requiresDj: true }),
  new SimplePublishCommand(stubRuntime, { name: 'pause', description: 'Paused', requiresDj: true }),
  new SimplePublishCommand(stubRuntime, { name: 'resume', description: 'Resumed', requiresDj: true }),
  new SimplePublishCommand(stubRuntime, { name: 'stop', description: 'Stopped', requiresDj: true }),
  new VolumeCommand(stubRuntime),
  new LoopCommand(stubRuntime),
  new SeekCommand(stubRuntime),
  new NowPlayingCommand(stubRuntime),
  new QueueCommand(stubRuntime),
  new ShuffleCommand(stubRuntime),
  new RemoveCommand(stubRuntime),
  new ClearCommand(stubRuntime),
  new MoveCommand(stubRuntime),
];
const commands = [
  new SlashCommandBuilder().setName('ping').setDescription('Replies with pong!'),
  ...registrationCommands.map((c) => c.buildSlashCommand()),
].map((c) => c.toJSON());

const rest = new REST({ version: '10' }).setToken(env.DISCORD_TOKEN);

// Redis clients - declared globally for use across functions
let redisPub: ReturnType<typeof createClient>;
let redisSub: ReturnType<typeof createClient>;
let secureRateLimiter: SecureRateLimiter;

// Command registry - declared globally
let commandRegistry: Map<string, import('@discord-bot/commands').BaseCommand>;

// Metrics counters
const registry = new Registry();
collectDefaultMetrics({ register: registry });
const cmdCounter = new Counter({ name: 'discord_commands_total', help: 'Total slash commands', labelNames: ['command'], registers: [registry] });
const btnCounter = new Counter({ name: 'discord_buttons_total', help: 'Total button clicks', labelNames: ['action'], registers: [registry] });
const redisPubCounter = new Counter({ name: 'redis_published_total', help: 'Published messages', labelNames: ['channel'], registers: [registry] });
const redisSubCounter = new Counter({ name: 'redis_consumed_total', help: 'Consumed messages', labelNames: ['channel'], registers: [registry] });

async function main() {
  const appId = env.DISCORD_APPLICATION_ID;
  const guildId = env.DISCORD_GUILD_ID;
  logger.info({ NOWPLAYING_UPDATE_MS: env.NOWPLAYING_UPDATE_MS, COMMANDS_CLEANUP_ON_START: env.COMMANDS_CLEANUP_ON_START, appId, guildId }, 'Gateway startup config');

  // Initialize Sentry error monitoring
  await initializeSentry({
    ...(env.SENTRY_DSN && { dsn: env.SENTRY_DSN }),
    environment: env.SENTRY_ENVIRONMENT,
    serviceName: 'gateway',
    tracesSampleRate: env.SENTRY_TRACES_SAMPLE_RATE,
    profilesSampleRate: env.SENTRY_PROFILES_SAMPLE_RATE
  });

  // 1) Login primero para que el bot aparezca online y pueda responder
  try {
    const res = await withTimeout(client.login(env.DISCORD_TOKEN), 20000, 'discord-login');
    if (!res) {
      logger.error('Login timed out or failed. Check DISCORD_TOKEN and intents. Will retry in 10s.');
      setTimeout(() => { void withTimeout(client.login(env.DISCORD_TOKEN), 20000, 'discord-login-retry'); }, 10000);
    }
  } catch (e) {
    logger.error({ e }, 'Login failed');
  }

  // 2) Registrar comandos en background (no bloquear inicio)
  void (async () => {
    try {
      const scope = (env.COMMANDS_SCOPE || 'global') as 'global'|'guild'|'both';
      const doGlobal = scope === 'global' || scope === 'both';
      const doGuild = scope === 'guild' || scope === 'both';

      let guildRegistered = false;
      if (doGuild && guildId) {
        logger.info({ appId, guildId }, 'Registering guild commands');
        if (env.COMMANDS_CLEANUP_ON_START) {
          try { await withTimeout(rest.put(Routes.applicationGuildCommands(appId, guildId), { body: [] }), 15000, 'guild-cleanup'); logger.info('Cleaned guild commands'); } catch (e) { logger.error({ e }, 'Guild cleanup failed'); }
        }
        const reg = await withTimeout(rest.put(Routes.applicationGuildCommands(appId, guildId), { body: commands }), 20000, 'guild-register');
        guildRegistered = !!reg;
        try {
          const g = (await withTimeout(rest.get(Routes.applicationGuildCommands(appId, guildId)) as unknown as Promise<unknown[]>, 15000, 'guild-get')) || [];
          logger.info({ guildCount: (g as unknown[]).length }, 'Guild command registry state');
        } catch { /* ignore */ }
      }

      if (doGlobal || !guildRegistered) {
        // Registrar global de forma estable; no limpiar salvo que el usuario lo pida expl√≠citamente
        const label = doGlobal ? 'global-register' : 'global-register-fallback';
        await withTimeout(rest.put(Routes.applicationCommands(appId), { body: commands }), 20000, label);
        try {
          const gl = (await withTimeout(rest.get(Routes.applicationCommands(appId)) as unknown as Promise<unknown[]>, 15000, 'global-get')) || [];
          logger.info({ globalCount: (gl as unknown[]).length }, 'Global command registry state');
        } catch { /* ignore */ }
      } else if (env.COMMANDS_CLEANUP_ON_START) {
        // Si solo queremos guild y el usuario pidi√≥ cleanup, limpiar los globales
        try { await withTimeout(rest.put(Routes.applicationCommands(appId), { body: [] }), 15000, 'global-clear'); logger.info('Cleared global commands'); } catch { /* ignore */ }
      }
    } catch (e) {
      logger.error({ e }, 'command registration failed');
    }
  })();
}

main().catch((err) => logger.error(err));

// Controls builder (reused across messages)

// Live Now Playing message (per guild)
type NowLive = { channelId: string; messageId: string; lastEdit?: number; lastUpdate?: number; state?: UiState & { trackUri?: string } };
const nowLive = new TTLMap<string, NowLive>({
  maxSize: 1000,           // Max 1000 guilds
  defaultTTL: 3600000,     // 1 hour TTL (removes inactive guilds)
  cleanupInterval: 300000  // Cleanup every 5 minutes
});

async function fetchNowPlaying(guildId: string) {
  const requestId = crypto.randomUUID();
  const channel = `discord-bot:response:${requestId}`;
  type NowPlayingResponse = { title: string; uri?: string; author?: string; durationMs: number; positionMs: number; isStream: boolean; artworkUrl?: string; paused?: boolean; repeatMode?: 'off' | 'track' | 'queue' } | null;
  const response: Promise<NowPlayingResponse> = new Promise((resolve) => {
    const handler = async (message: string, chan: string) => {
      if (chan !== channel) return;
      try { resolve(JSON.parse(message)); } finally { await redisSub.unsubscribe(channel); }
    };
    redisSub.subscribe(channel, (msg) => handler(msg, channel)).catch(() => undefined);
  });
  await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'nowplaying', guildId, requestId }));
  redisPubCounter.labels('discord-bot:commands').inc();
  const data = (await Promise.race([
    response,
    new Promise((res) => setTimeout(() => res(null), 1500)),
  ])) as NowPlayingResponse;
  return data;
}

function buildNowEmbed(data: NonNullable<Awaited<ReturnType<typeof fetchNowPlaying>>>) {
  const total = data.durationMs || 0;
  const pos = data.positionMs || 0;
  const pct = total > 0 ? Math.min(1, pos / total) : 0;
  const barLen = 20;
  const filled = Math.min(barLen - 1, Math.round(pct * barLen));
  const bar = '‚ñ¨'.repeat(filled) + 'üîò' + '‚ñ¨'.repeat(Math.max(0, barLen - filled - 1));
  const fmt = (ms: number) => {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const ss = s % 60;
    return `${m}:${ss.toString().padStart(2, '0')}`;
  };
  const ytMatch = data.uri?.match(/(?:v=|youtu\.be\/)([\w-]{11})/);
  const thumb = data.artworkUrl ?? (ytMatch ? `https://i.ytimg.com/vi/${ytMatch[1]}/hqdefault.jpg` : undefined);
  const description = data.uri ? `[${data.title}](${data.uri})` : `${data.title}`;
  const embed = new EmbedBuilder()
    .setTitle('Now Playing')
    .setDescription(description)
    .addFields(
      { name: 'Author', value: data.author ?? 'Unknown', inline: true },
      { name: 'Progress', value: data.isStream ? 'live' : `${fmt(pos)} ${bar} ${fmt(total)}`, inline: false },
    )
    .setColor(0x57f287);
  if (thumb) embed.setThumbnail(thumb);
  return embed;
}

async function ensureLiveNow(guildId: string, channelId: string, forceRelocate = false) {
  const data = await fetchNowPlaying(guildId);
  const channel = await resolveTextChannel(client, channelId);
  if (!channel) return;
  const autoplayOn = await getAutomixEnabled(guildId);
  // Quick approximation for initial controls
  const loopMode = (data?.repeatMode as 'off' | 'track' | 'queue') || 'off';
  const hasTrack = !!data;
  const canSeek = !!data && !data.isStream;
  const queueLen = 0;
  const controls = buildControls({ autoplayOn, loopMode, paused: false, hasTrack, queueLen, canSeek });
  if (!data) { return; }
  const embed = buildNowEmbed(data);
  const existing = nowLive.get(guildId);

  if (existing) {
    // Safely fetch existing message
    const msg = await safeDiscordOperation(
      () => channel.messages.fetch(existing.messageId),
      `fetch_message_${guildId}`,
      {
        maxRetries: 1,
        onError: (error) => {
          logger.debug({ guildId, messageId: existing.messageId, error: error.message }, 'Failed to fetch existing message');
        }
      }
    );

    if (msg && !forceRelocate) {
      // Safely update existing message
      await safeDiscordOperation(
        () => msg.edit({ embeds: [embed], components: controls }),
        `edit_message_${guildId}`,
        {
          maxRetries: 2,
          fallback: async () => {
            // Fallback: send new message and clean up old one
            logger.info({ guildId }, 'Edit failed, sending new message as fallback');
            const sent = await channel.send({ embeds: [embed], components: controls });
            await safeDiscordOperation(
              () => msg.delete(),
              `delete_old_message_${guildId}`,
              { maxRetries: 1 }
            );
            nowLive.set(guildId, { channelId, messageId: sent.id, lastUpdate: Date.now() });
            return sent;
          },
          onError: (error) => {
            logger.warn({ guildId, messageId: msg.id, error: error.message }, 'Failed to edit message');
          }
        }
      );
    } else {
      // Send new message and clean up old one
      const sent = await safeDiscordOperation(
        () => channel.send({ embeds: [embed], components: controls }),
        `send_new_message_${guildId}`,
        {
          maxRetries: 3,
          onError: (error) => {
            logger.error({ guildId, channelId, error: error.message }, 'Failed to send new message');
          }
        }
      );

      if (sent) {
        // Clean up old message if it exists
        if (msg) {
          await safeDiscordOperation(
            () => msg.delete(),
            `delete_old_message_${guildId}`,
            {
              maxRetries: 1,
              onError: () => {
                logger.debug({ guildId, messageId: msg.id }, 'Could not delete old message (already deleted?)');
              }
            }
          );
        }
        nowLive.set(guildId, { channelId, messageId: sent.id, lastUpdate: Date.now() });
      }
      return;
    }
  } else {
    // Send initial message
    const sent = await safeDiscordOperation(
      () => channel.send({ embeds: [embed], components: controls }),
      `send_initial_message_${guildId}`,
      {
        maxRetries: 3,
        onError: (error) => {
          logger.error({ guildId, channelId, error: error.message }, 'Failed to send initial message');
        }
      }
    );

    if (sent) {
      nowLive.set(guildId, { channelId, messageId: sent.id, lastUpdate: Date.now() });
    }
  }
  // No interval here; updates are driven by push events from audio (playerUpdate)
  // (Do not overwrite messageId here to avoid losing the reference and duplicating messages)
}

// push update subscription is set after Redis connection (see later)

// Cleanup live message state when guild or channel is removed
client.on('guildDelete', (g) => {
  nowLive.delete(g.id);
});
client.on('channelDelete', (ch) => {
  const id = (ch as unknown as { id?: string } | null)?.id;
  for (const [gid, live] of nowLive) {
    if (id && live.channelId === id) nowLive.delete(gid);
  }
});

// Cuando el bot se desconecta del canal de voz, olvidamos el mensaje vivo para
// evitar seguir editando uno antiguo. Al volver a reproducir, se crear√° uno nuevo al final.
client.on('voiceStateUpdate', (oldState, newState) => {
  try {
    const meId = client.user?.id;
    if (!meId) return;
    // Evento propio del bot
    if (newState.member?.user?.id !== meId && oldState.member?.user?.id !== meId) return;
    // Desconexi√≥n: channelId -> null
    if (oldState.channelId && !newState.channelId) {
      nowLive.delete(newState.guild.id);
    }
  } catch { /* ignore */ }
});

client.on('interactionCreate', withErrorHandling(async (interaction) => {
  if (!interaction.isChatInputCommand()) return;
  try {
    if (interaction.guildId) {
      const guildValidation = validateSnowflake(interaction.guildId, 'Guild ID');
      if (!guildValidation.success) {
        await interaction.reply({ content: 'Invalid guild context.', ephemeral: true });
        return;
      }
    }
    if (interaction.commandName === 'ping') {
      await interaction.reply('Pong!');
      return;
    }
    const cmd = commandRegistry.get(interaction.commandName);
    if (!cmd) {
      logger.warn({ command: interaction.commandName }, 'Unknown command');
      await interaction.reply({ content: 'Unknown command.', ephemeral: true });
      return;
    }
    await cmd.run(interaction);
  } catch (error) {
    await handleInteractionError(error as Error, interaction, 'chat_command');
  }
}, 'interaction_handler'));

async function initializeGateway() {
  // Redis bridge: forward Discord RAW to audio and send payloads from audio to Discord shards
  const redisUrl = env.REDIS_URL;
  redisPub = createClient({ url: redisUrl });
  redisSub = createClient({ url: redisUrl });

  await redisPub.connect();
  await redisSub.connect();

  // Initialize secure rate limiter
  secureRateLimiter = new SecureRateLimiter(redisPub);

// Unified command runtime and registry
const runtime: MusicRuntime = {
  publish: (channel: string, message: string) => redisPub.publish(channel, message).then(() => {}),
  subscribeOnce: (channel: string) => new Promise<string | null>((resolve) => {
    const handler = async (message: string, chan: string) => {
      if (chan !== channel) return;
      try { resolve(message); } finally { await redisSub.unsubscribe(channel); }
    };
    // redis v4 subscribe signature: (channel, listener)
    redisSub.subscribe(channel, (msg: string) => handler(msg, channel)).catch(() => resolve(null));
  }),
  incPublishMetric: (channel) => { try { redisPubCounter.labels(channel).inc(); } catch { /* ignore */ } },
  hasDjOrAdmin: (i) => hasDjOrAdmin(i),
  allow: async (interaction, cmd, limit = 10, windowSec = 60) => {
    const result = await secureRateLimiter.isAllowed(interaction, cmd, {
      limit,
      windowSec,
      fallbackLimit: Math.floor(limit * 0.3) // More restrictive fallback
    });

    if (result.usingFallback) {
      logger.warn({
        guildId: interaction.guildId,
        userId: interaction.user.id,
        command: cmd,
        remaining: result.remaining,
        usingFallback: true
      }, 'Rate limiting using fail-safe fallback');
    }

    return result.allowed;
  },
  ensureLiveNow: async (g, ch, force) => ensureLiveNow(g, ch, force),
  validators: { validateSearchQuery, validateInteger, validateLoopMode },
};

commandRegistry = new Map<string, import('@discord-bot/commands').BaseCommand>();
const commandInstances = [
  new PlayCommand(runtime),
  new SimplePublishCommand(runtime, { name: 'skip', description: 'Skipped', requiresDj: true }),
  new SimplePublishCommand(runtime, { name: 'pause', description: 'Paused', requiresDj: true }),
  new SimplePublishCommand(runtime, { name: 'resume', description: 'Resumed', requiresDj: true }),
  new SimplePublishCommand(runtime, { name: 'stop', description: 'Stopped', requiresDj: true }),
  new VolumeCommand(runtime),
  new LoopCommand(runtime),
  new SeekCommand(runtime),
  new NowPlayingCommand(runtime),
  new QueueCommand(runtime),
  new ShuffleCommand(runtime),
  new RemoveCommand(runtime),
  new ClearCommand(runtime),
  new MoveCommand(runtime),
];
for (const c of commandInstances) commandRegistry.set(c.metadata.name, c);

// Subscribe to UI push updates from audio and update the live message efficiently
const rawMs = env.NOWPLAYING_UPDATE_MS ?? 5000;
const uiIntervalMs = Math.max(1000, Math.min(60000, Number.isFinite(rawMs as number) ? (rawMs as number) : 5000));

  await redisSub.subscribe('discord-bot:ui:now', async (message) => {
  try {
    const data = JSON.parse(message) as { guildId: string; title: string; uri?: string; author?: string; durationMs: number; positionMs: number; isStream: boolean; artworkUrl?: string; paused?: boolean; repeatMode?: 'off'|'track'|'queue'; queueLen?: number; hasTrack?: boolean; canSeek?: boolean };
    if (!data || !data.guildId) return;
    if (data.paused) return; // don't update while paused
    let live = nowLive.get(data.guildId);
    if (!live) {
      // Try to create the live message automatically using stored textChannelId
      try {
        const q = await prisma.queue.findFirst({ where: { guildId: data.guildId }, select: { textChannelId: true } });
        const chId = q?.textChannelId;
        if (chId) {
          const ch = client.channels.cache.get(chId) as TextChannel | null;
          const channel = ch ?? (await client.channels.fetch(chId).catch(() => null) as TextChannel | null);
          if (channel) {
            const embed = buildNowEmbed({ title: data.title, uri: data.uri, author: data.author, durationMs: data.durationMs, positionMs: data.positionMs, isStream: data.isStream, artworkUrl: data.artworkUrl } as { title: string; uri?: string; author?: string; durationMs: number; positionMs: number; isStream: boolean; artworkUrl?: string });
            const state: UiState = {
              autoplayOn: await getAutomixEnabled(data.guildId),
              loopMode: data.repeatMode ?? 'off',
              paused: !!data.paused,
              hasTrack: data.hasTrack ?? true,
              queueLen: data.queueLen ?? 0,
              canSeek: data.canSeek ?? !data.isStream,
            };
            const controls = buildControls(state);
            const sent = await channel.send({ embeds: [embed], components: controls });
            const stateWithUri: UiState & { trackUri?: string } = { ...state };
            if (data.uri !== undefined) {
              stateWithUri.trackUri = data.uri;
            }
            nowLive.set(data.guildId, { channelId: channel.id, messageId: sent.id, lastEdit: Date.now(), state: stateWithUri });
            live = nowLive.get(data.guildId);
          }
        }
      } catch (e) {
        logger.error({ e }, 'ui:now auto-create failed');
        return;
      }
      if (!live) return; // couldn't create automatically
    }
    const now = Date.now();
    if (live.lastEdit && now - live.lastEdit < uiIntervalMs) return; // debounce edits
    const ch = client.channels.cache.get(live.channelId) as TextChannel | null;
    if (!ch) return;
    const msg = await ch.messages.fetch(live.messageId).catch(() => null);
    const embed = buildNowEmbed({ title: data.title, uri: data.uri, author: data.author, durationMs: data.durationMs, positionMs: data.positionMs, isStream: data.isStream, artworkUrl: data.artworkUrl } as { title: string; uri?: string; author?: string; durationMs: number; positionMs: number; isStream: boolean; artworkUrl?: string });
    const state: UiState = {
      autoplayOn: await getAutomixEnabled(data.guildId),
      loopMode: data.repeatMode ?? 'off',
      paused: !!data.paused,
      hasTrack: data.hasTrack ?? true,
      queueLen: data.queueLen ?? 0,
      canSeek: data.canSeek ?? !data.isStream,
    };
    const controls = buildControls(state);
    // Always edit the same message; do not recreate per track
    if (!msg) {
      const newMsg = await ch.send({ embeds: [embed], components: controls });
      const stateWithUri1: UiState & { trackUri?: string } = { ...state };
      if (data.uri !== undefined) {
        stateWithUri1.trackUri = data.uri;
      }
      nowLive.set(data.guildId, { channelId: live.channelId, messageId: newMsg.id, lastEdit: now, state: stateWithUri1 });
    } else {
      // Try to edit existing message, but create new one if it fails
      try {
        await msg.edit({ embeds: [embed], components: controls });
        const stateWithUri2: UiState & { trackUri?: string } = { ...state };
        if (data.uri !== undefined) {
          stateWithUri2.trackUri = data.uri;
        }
        nowLive.set(data.guildId, { ...live, lastEdit: now, state: stateWithUri2 });
      } catch {
        // Message doesn't exist anymore, create a new one
        const newMsg = await ch.send({ embeds: [embed], components: controls });
        const stateWithUri3: UiState & { trackUri?: string } = { ...state };
        if (data.uri !== undefined) {
          stateWithUri3.trackUri = data.uri;
        }
        nowLive.set(data.guildId, { channelId: live.channelId, messageId: newMsg.id, lastEdit: now, state: stateWithUri3 });
      }
    }
  } catch (e) {
    logger.error({ e }, 'ui:now update failed');
  }
});

client.on('raw', async (d) => {
  try {
    await redisPub.publish('discord-bot:to-audio', JSON.stringify(d));
  } catch (e) {
    logger.error({ e }, 'failed to publish raw to audio');
  }
});

  await redisSub.subscribe('discord-bot:to-discord', async (message) => {
  try {
    const { guildId, payload } = JSON.parse(message) as {
      guildId: string;
      payload: unknown;
    };
    redisSubCounter.labels('discord-bot:to-discord').inc();
    const shardId =
      client.guilds.cache.get(guildId)?.shardId ??
      (Number((BigInt(guildId) >> 22n) % BigInt(client.ws.shards.size)) || 0);
    const shard = client.ws.shards.get(shardId);
    if (!shard) return;
    await shard.send(payload as Record<string, unknown>);
  } catch (e) {
    logger.error({ e }, 'failed to dispatch payload to shard');
  }
});

// Button Interactions
client.on('interactionCreate', withErrorHandling(async (interaction) => {
  if (!interaction.isButton()) return;
  const guildId = interaction.guildId;
  const id = interaction.customId;
  try {
    if (!guildId) { await interaction.reply({ content: 'Guild-only control.', ephemeral: true }); return; }
    
    // Validate guild ID for security
    const guildValidation = validateSnowflake(guildId, 'Guild ID');
    if (!guildValidation.success) {
      await interaction.reply({ content: 'Invalid guild context.', ephemeral: true });
      return;
    }
    if (!hasDjOrAdmin(interaction)) return await interaction.reply({ content: `Requires ${env.DJ_ROLE_NAME} role.`, ephemeral: true });
    switch (id) {
      case 'music:toggle':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'toggle' }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'toggle', guildId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        // restart live updater shortly after toggling (resume or pause)
        if (interaction.channelId) setTimeout(() => { void ensureLiveNow(guildId, interaction.channelId!); }, 700);
        return;
      case 'music:skip':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'skip' }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'skip', guildId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:stop':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'stop' }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'stop', guildId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:loop': {
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'loop-toggle' }, 'button');
        const live = nowLive.get(guildId);
        const cur = live?.state?.loopMode ?? 'off';
        const next = cur === 'off' ? 'track' : cur === 'track' ? 'queue' : 'off';
        const autoplay = live?.state?.autoplayOn ?? (await getAutomixEnabled(guildId));
        if (next !== 'off' && autoplay) {
          await setAutomixEnabled(guildId, false);
        }
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'loop', guildId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        if (interaction.channelId) void ensureLiveNow(guildId, interaction.channelId);
        return;
      }
      case 'music:shuffle':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'shuffle' }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'shuffle', guildId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:seekback':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'seek', deltaMs: -10000 }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'seekAdjust', guildId, deltaMs: -10000 }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:seekfwd':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'seek', deltaMs: 10000 }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'seekAdjust', guildId, deltaMs: 10000 }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:volup':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'volume', delta: 10 }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'volumeAdjust', guildId, delta: 10 }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:voldown':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'volume', delta: -10 }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'volumeAdjust', guildId, delta: -10 }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:clear':
        await interaction.deferUpdate();
        logger.info({ guildId, userId: interaction.user.id, action: 'clear' }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'clear', guildId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        return;
      case 'music:autoplay':
      case 'music:automix': { // legacy id support
        await interaction.deferUpdate();
        const current = await getAutomixEnabled(guildId);
        const next = !current;
        logger.info({ guildId, userId: interaction.user.id, action: 'autoplay', enabled: next }, 'button');
        await setAutomixEnabled(guildId, next);
        if (next) {
          await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'loopSet', guildId, mode: 'off' }));
          redisPubCounter.labels('discord-bot:commands').inc();
          const live = nowLive.get(guildId);
          const queueLen = live?.state?.queueLen ?? 0;
          const hasTrack = live?.state?.hasTrack ?? false;
          if (hasTrack && queueLen === 0) {
            await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'seedRelated', guildId }));
            redisPubCounter.labels('discord-bot:commands').inc();
          }
        }
        if (interaction.channelId) void ensureLiveNow(guildId, interaction.channelId);
        return;
      }
      case 'music:queue': {
        const requestId = crypto.randomUUID();
        const channel = `discord-bot:response:${requestId}`;
        type QueuePayload = { items: Array<{ title: string; uri?: string }> } | null;
        const response: Promise<QueuePayload> = new Promise((resolve) => {
          const handler = async (message: string, chan: string) => {
            if (chan !== channel) return;
            try { resolve(JSON.parse(message)); } finally { await redisSub.unsubscribe(channel); }
          };
          redisSub.subscribe(channel, (msg) => handler(msg, channel)).catch(() => undefined);
        });
        logger.info({ guildId, userId: interaction.user.id, action: 'queue' }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'queue', guildId, requestId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        const data = (await Promise.race([
          response,
          new Promise((res) => setTimeout(() => res(null), 1500)),
        ])) as QueuePayload;
        if (!data || !data?.items || data.items.length === 0) {
          await interaction.reply({ content: 'Queue is empty.', ephemeral: true });
        } else {
          const desc = data.items.slice(0, 10).map((t: { title: string; uri?: string }, i: number) => `${i + 1}. [${t.title}](${t.uri})`).join('\n');
          const embed = new EmbedBuilder().setTitle('Queue').setDescription(desc).setColor(0xfee75c);
          await interaction.reply({ embeds: [embed], ephemeral: true });
        }
        return;
      }
      case 'music:now': {
        const requestId = crypto.randomUUID();
        const channel = `discord-bot:response:${requestId}`;
        type NowPlayingResponse = { title: string; uri?: string; author?: string; durationMs: number; positionMs: number; isStream: boolean; artworkUrl?: string } | null;
        const response: Promise<NowPlayingResponse> = new Promise((resolve) => {
          const handler = async (message: string, chan: string) => {
            if (chan !== channel) return;
            try { resolve(JSON.parse(message)); } finally { await redisSub.unsubscribe(channel); }
          };
          redisSub.subscribe(channel, (msg) => handler(msg, channel)).catch(() => undefined);
        });
        logger.info({ guildId, userId: interaction.user.id, action: 'now' }, 'button');
        await redisPub.publish('discord-bot:commands', JSON.stringify({ type: 'nowplaying', guildId, requestId }));
        redisPubCounter.labels('discord-bot:commands').inc();
        const data = (await Promise.race([
          response,
          new Promise((res) => setTimeout(() => res(null), 1500)),
        ])) as NowPlayingResponse;
        if (!data) {
          await interaction.reply({ content: 'No track playing.', ephemeral: true });
        } else {
          const total = data.durationMs || 0;
          const pos = data.positionMs || 0;
          const pct = total > 0 ? Math.min(1, pos / total) : 0;
          const barLen = 20;
          const filled = Math.min(barLen - 1, Math.round(pct * barLen));
          const bar = '‚îÄ'.repeat(filled) + '‚óè' + '‚îÄ'.repeat(Math.max(0, barLen - filled - 1));
          const fmt = (ms: number) => {
            const s = Math.floor(ms / 1000);
            const m = Math.floor(s / 60);
            const ss = s % 60;
            return `${m}:${ss.toString().padStart(2, '0')}`;
          };
          const ytMatch = data.uri?.match(/(?:v=|youtu\.be\/)([\w-]{11})/);
          const thumb = data.artworkUrl ?? (ytMatch ? `https://i.ytimg.com/vi/${ytMatch[1]}/hqdefault.jpg` : undefined);
          const embed = new EmbedBuilder()
            .setTitle('Now Playing')
            .setDescription(`[${data.title}](${data.uri})`)
            .addFields(
              { name: 'Author', value: data.author ?? 'Unknown', inline: true },
              { name: 'Progress', value: data.isStream ? 'live' : `${fmt(pos)} ${bar} ${fmt(total)}`, inline: false },
            )
            .setColor(0x57f287);
          if (thumb) embed.setThumbnail(thumb);
          await interaction.reply({ embeds: [embed], ephemeral: true });
        }
        return;
      }
      default:
        // Unknown button interaction
        return;
    }
    // Most handlers use deferUpdate() and do not send an extra message.
  } catch (error) {
    await handleInteractionError(error as Error, interaction, 'button_interaction');
    return;
  }
}, 'button_handler'));

// Health Check Setup - Using simplified health check for now
const healthStatus = {
  status: 'healthy',
  version: '1.0.0',
  service: 'gateway'
};

// Metrics and Health server (using previously declared registry and counters)

client.on('interactionCreate', (i: import('discord.js').Interaction) => {
  if (i.isChatInputCommand()) cmdCounter.labels(i.commandName).inc();
  if (i.isButton()) btnCounter.labels(i.customId).inc();
});

const healthServer = http.createServer(async (req, res) => {
  if (!req.url) return;
  
  // Enhanced health endpoint
  if (req.url.startsWith('/health')) {
    try {
      const health = {
        ...healthStatus,
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        discord: client.isReady(),
      };
      
      res.writeHead(200, { 'content-type': 'application/json' });
      res.end(JSON.stringify(health, null, 2));
    } catch (error) {
      res.writeHead(503, { 'content-type': 'application/json' });
      res.end(JSON.stringify({
        service: 'gateway',
        status: 'unhealthy',
        error: error instanceof Error ? error.message : String(error),
        timestamp: new Date().toISOString(),
      }));
    }
    return;
  }
  
  // Simple readiness probe
  if (req.url.startsWith('/ready')) {
    const ready = client.isReady();
    res.writeHead(ready ? 200 : 503, { 'content-type': 'application/json' });
    res.end(JSON.stringify({ ready, timestamp: new Date().toISOString() }));
    return;
  }
  if (req.url.startsWith('/metrics')) {
    res.writeHead(200, { 'content-type': registry.contentType });
    res.end(await registry.metrics());
    return;
  }
  res.writeHead(404);
  res.end();
});
healthServer.listen(env.GATEWAY_HTTP_PORT, () => logger.info(`Gateway health on :${env.GATEWAY_HTTP_PORT}`));

// Simple redis metrics instrumentation at call sites

  // Tracing
  if (env.OTEL_EXPORTER_OTLP_ENDPOINT) {
    const sdk = new NodeSDK({
      traceExporter: new OTLPTraceExporter({ url: env.OTEL_EXPORTER_OTLP_ENDPOINT }),
      instrumentations: [getNodeAutoInstrumentations()],
    });
    void sdk.start();
  }
}

// Graceful shutdown handler
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully...');

  try {
    // Cleanup rate limiter
    if (secureRateLimiter) {
      secureRateLimiter.destroy();
    }

    // Cleanup TTL maps
    nowLive.destroy();

    // Disconnect Redis
    if (redisPub) await redisPub.disconnect();
    if (redisSub) await redisSub.disconnect();

    // Disconnect Discord
    if (client) client.destroy();

    logger.info('Gateway shutdown complete');
    process.exit(0);
  } catch (error) {
    logger.error({ error }, 'Error during shutdown');
    process.exit(1);
  }
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down...');
  process.emit('SIGTERM');
});

void initializeGateway();
